#!/usr/bin/env python
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2013 Midokura PTE LTD.
# All Rights Reserved
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# @author: Guillermo Ontanon <guillermo@midokura.com>, Midokura

import cmd
import re
import readline
import sys
from shlex import split as shsplit

from midonetclient.api import MidonetApi

# TODO:
#   + Command space completeness:
#       - add full specs for all API objects

################################################################################
# Utility functions
################################################################################

uuid_pattern = re.compile("^[0-F]{8}-[0-F]{4}-[0-F]{4}-[0-F]{4}-[0-F]{12}$", re.I)
def is_valid_uuid(value):
    return True if uuid_pattern.match(value) is not None else False

################################################################################
# Session initialization
################################################################################

class Session():
    def __init__(self):
        self.api_url = None
        self.username = None
        self.password = None
        self.tenant_id = None
        self.enable_alias_manager = True
        self.do_eval = False

    def _load_from_config_file(self):
        import ConfigParser
        import os
        home = os.path.expanduser("~")
        try:
            cfg = ConfigParser.ConfigParser()
            cfgfile = "%s%s%s" % (home, os.path.sep, '.midonetrc')
            cfg.read(cfgfile)
        except:
            return
        if cfg.has_option('cli', 'api_url'):
            self.api_url = cfg.get('cli', 'api_url')
        if cfg.has_option('cli', 'username'):
            self.username = cfg.get('cli', 'username')
        if cfg.has_option('cli', 'password'):
            self.password = cfg.get('cli', 'password')
        if cfg.has_option('cli', 'tenant'):
            self.tenant_id = cfg.get('cli', 'tenant')

    def _load_from_env(self):
        import os
        if os.environ.has_key('MIDO_API_URL'):
            self.api_url = os.environ['MIDO_API_URL']
        if os.environ.has_key('MIDO_USER'):
            self.username = os.environ['MIDO_USER']
        if os.environ.has_key('MIDO_TENANT'):
            self.tenant_id = os.environ['MIDO_TENANT']

    def _load_from_args(self):
        from optparse import OptionParser
        parser = OptionParser()
        parser.add_option("-A", "--no-auth", dest="skip_auth",
                            action="store_true",
                            help="Skip authentication")
        parser.add_option("--midonet-url", dest="api_url",
                            help="Midonet API server URL", metavar="URL")
        parser.add_option("-u", "--user", dest="username",
                            help="Username", metavar="USERNAME")
        parser.add_option("--tenant", dest="tenant",
                            help="Tenant id", metavar="UUID")
        parser.add_option("-e", "--eval", dest="do_eval", action="store_true",
                            help="Evaluate a single command, given at the end "+
                                 "of the argument list")
        parser.add_option("-p", "--password", dest="ask_for_password",
                            help="Ask for password interactively",
                            action="store_true")
        (options, args) = parser.parse_args()
        if not options.do_eval and args is not None and len(args) > 0:
            raise Exception("Unrecognized command")
        if options.do_eval:
            self.command = " ".join(args)
        if not options.skip_auth and options.ask_for_password and \
                sys.__stdin__.isatty():
            from getpass import getpass
            self.password = getpass()
        if options.api_url is not None:
            self.api_url = options.api_url
        if options.username is not None:
            self.username = options.username
        if options.tenant is not None:
            self.tenant_id = options.tenant
        if not sys.__stdin__.isatty() or options.do_eval:
            self.enable_alias_manager = False
        self.do_auth = not options.skip_auth

    def load(self):
        self._load_from_config_file()
        self._load_from_env()
        self._load_from_args()

        if self.api_url is None:
            raise Exception("Missing: Midonet API URL")
        if self.do_auth and self.username is None:
            raise Exception("Missing: username")
        if self.tenant_id is None:
            raise Exception("Missing: tenant id")
        if self.do_auth and self.password is None:
            raise Exception("No password given (add it to ~/.midonetrc or "+
                            "get a prompt using the -p option)")

    def connect(self):
        import logging
        auth = None
        logging.basicConfig()
        logger = logging.getLogger('midonet.api')
        logger.setLevel(logging.CRITICAL)
        return MidonetApi(self.api_url, self.username, self.password)


################################################################################
# Field value types
################################################################################

class ValueType():
    def __init__(self):
        pass

    def is_valid(self, value):
        return True

class ObjectRef(ValueType):
    """A reference to an object found in the root lookup context (see class
       Midonet)"""
    def __init__(self, top_level_collection):
        self.collection = top_level_collection

class StringType(ValueType):
    pass

class IPv4Address(ValueType):
    pass

class IPv4Subnet(ValueType):
    pass

class Enum(ValueType):
    def __init__(self, first, *rest):
        list(rest).insert(0, first)
        self._values = rest

    def is_valid(self, value):
        return True if value in self._values else False

################################################################################
# Object member types
################################################################################

class Attr():
    pass

class SingleAttr(Attr):
    def __init__(self, name, value_type, getter,
                 setter = None,
                 writeable = True,
                 show = True,
                 optional = False):
        self.name = name
        self.value_type = value_type
        self.getter = getter
        self.setter = setter
        self.writeable = writeable
        self.show = show
        self.optional = optional

    def fetch(self, obj):
        func = obj.reflect(self.getter)
        return func()

    def set(self, obj, value):
        func = obj.reflect(self.setter)
        func(value)

class TenantAttr(SingleAttr):
    def __init__(self):
        SingleAttr.__init__(self,
                            name = 'tenant_id',
                            value_type = StringType,
                            getter = 'get_tenant_id',
                            setter = 'tenant_id',
                            writeable = True,
                            show = False)

class CidrPair(SingleAttr):
    def __init__(self, name, value_type,
                 addr_getter,
                 mask_getter,
                 addr_setter = None,
                 mask_setter = None,
                 writeable = True,
                 show = True,
                 optional = False):
        SingleAttr.__init__(self, name, value_type,
                            getter = None,
                            setter = None,
                            writeable = writeable,
                            show = show,
                            optional = optional)
        self.addr_getter = addr_getter
        self.addr_setter = addr_setter
        self.mask_getter = mask_getter
        self.mask_setter = mask_setter

    def fetch(self, obj):
        func = obj.reflect(self.addr_getter)
        address = func()
        func = obj.reflect(self.mask_getter)
        mask = func()
        if address is None:
            return None

        address = address if address else '0.0.0.0'
        mask = mask if mask else '0'
        return "%s/%s" % (address, mask)

    def set(self, obj, value):
        values = value.split('/')
        if len(values) != 2:
            raise Exception("Invalid network address: %s" % value)
        func = obj.reflect(self.addr_setter)
        func(values[0])
        func = obj.reflect(self.mask_setter)
        func(values[1])

class Collection(Attr):
    def __init__(self, name, element_type, list_method,
                 list_with_tenant = False,
                 getter = None,
                 factory_method = None,
                 show = True):
        self.name = name
        self.element_type = element_type
        self.list_method = list_method
        self.getter = getter
        self.list_with_tenant = list_with_tenant
        self.factory_method = factory_method
        self.show = show

################################################################################
# Alias manager
################################################################################

class Namespace():
    def __init__(self):
        self._aliases = {}
        self._reverse_aliases = {}
        self._prefixes = {}

    def empty(self):
        return (len(self._aliases.keys()) == 0)

    def names(self):
        return self._aliases.iterkeys()

    def make_name(self, prefix):
        count = 0
        if self._prefixes.has_key(prefix):
            count = self._prefixes[prefix] + 1
        self._prefixes[prefix] = count
        return "%s%s" % (prefix, count)

    def lookup(self, name):
        if self._aliases.has_key(name):
            return self._aliases[name]
        else:
            return None

    def reverse_lookup(self, uuid):
        if self._reverse_aliases.has_key(uuid):
            return self._reverse_aliases[uuid]
        else:
            return None

    def add(self, obj):
        uuid = obj.fetch_field('id')
        if self._reverse_aliases.has_key(uuid):
            return self._reverse_aliases[uuid]

        alias = self.make_name(obj.type_name())
        self._aliases[alias] = uuid
        self._reverse_aliases[uuid] = alias
        return alias

class AliasManager():
    def __init__(self):
        self._namespaces = {}
        self._root_namespace = Namespace()

    def _get_namespace(self, uuid):
        if self._namespaces.has_key(uuid):
            return self._namespaces[uuid]
        else:
            return Namespace()

    # FIXME - aliases are hierarchical and composed with a ':' separator. For
    # example, given a router with alias router0 that contains a port aliased
    # to port0. 'port0' is scoped to router0, other port0's may exist in other
    # router objects. Resolving a 'port0' can be done by passing router0 as
    # parent. port0 may also be resolved by querying for 'router0:port0' with
    # no parent object, however if the returned uuid is not available in the
    # root app context, the caller will not know what to do with it. Thus,
    # composed names cannot be used in the CLI yet, until this sort of traversal
    # is supported. To refer to 'router0:port0' one has to write
    # 'router router0 port port0' to let the parser know which path to take
    # in the object tree: "1st, lookup in the list of routers, then in the list
    # of ports of the found router".
    #
    # The solution is to add attribute specs (returned by attrs() in the object
    # definition) to each component in the chain of aliases. So aliases need to
    # store both uuid and attribute spec.
    def lookup(self, name, parent=None):
        chain = name.split(':')
        namespace = self._root_namespace
        resolved = None

        if isinstance(parent, Midonet):
            parent = None
        if parent is not None:
            if isinstance(parent, ObjectType):
                parent = parent.fetch_field('id')
            resolved_parent = self.lookup(parent)
            if resolved_parent is not None:
                parent = resolved_parent
            namespace = self._get_namespace(parent)

        for elem in chain:
            resolved = namespace.lookup(elem)
            if resolved is None:
                return None
            else:
                namespace = self._get_namespace(resolved)

        return resolved

    def complete(self, name, parent=None):
        namespace = self._root_namespace
        resolved = None

        if isinstance(parent, Midonet):
            parent = None
        if parent is not None:
            if isinstance(parent, ObjectType):
                parent = parent.fetch_field('id')
            resolved_parent = self.lookup(parent)
            if resolved_parent is not None:
                parent = resolved_parent
            namespace = self._get_namespace(parent)

        # FIXME: ignoring composed aliases (which are not fully implemented yet)
        completions = []
        for alias in namespace.names():
            if alias.startswith(name):
                completions.append(alias)
        return completions

    def add(self, *obj):
        namespace = self._root_namespace
        objects = list(obj)
        chain = []
        while len(objects) > 0:
            o = objects.pop(0)
            if not o.has_field('id'):
                return []
            uuid = o.fetch_field('id')

            if o.alias_from_root:
                namespace = self._root_namespace
            alias = namespace.reverse_lookup(uuid)
            if alias is None:
                alias = namespace.add(o)
                self._namespaces[uuid] = Namespace()

            namespace = self._namespaces[uuid]
            chain.append(alias)

        return chain

class NoOpAliasManager():
    def __init__(self):
        pass

    def lookup(self, name, parent=None):
        return None

    def complete(self, name, parent=None):
        return []

    def add(self, *obj):
        return map(lambda o: o.fetch_field('id'), list(obj))

################################################################################
# Object types
################################################################################

class FieldType():
    def __init__(self, name, attr_spec, value):
        self.name = name
        self.value = value
        self._type = attr_spec.value_type
        self._spec = attr_spec

    def dereference(self):
        if isinstance(self._type, ObjectRef):
            o = app.fetch_one_for_type(self._type.collection, self.value)
            if o:
                o.alias_from_root = True
            return o
        else:
            return self

    def describe(self):
        return "%s: %s" % (self.name, self.value)

class ObjectType():
    """ This is the base class to define CLI wrappers around REST API objects.
        Mainly, it provides an `attrs` method that describes the structure of
        the wrapped type and how they should be treated by the CLI. Most
        subclasses should override `attrs`.

        The rest of its methods work on the structural definition provided by
        `attrs` to let Command implementations generically traverse and
        manipulate the underlying REST API object."""

    def __init__(self, obj):
        self._aliases = {}
        self._object = obj
        self._attrs = {}
        self._attr_list = []
        self.alias_from_root = False
        self.put_attr(SingleAttr(name = 'id',
                                 value_type = StringType(),
                                 getter = 'get_id',
                                 show = False,
                                 writeable = False,
                                 optional = True))

    def object(self):
        return self._object

    def clear_attrs(self):
        self._attrs = {}
        self._attr_list = []

    def put_attr(self, attr):
        self._attrs[attr.name] = attr
        self._attr_list.append(attr)

    def type_name(self):
        return "object"

    def attrs(self):
        return self._attrs

    def fields(self):
        fields = filter(lambda a: isinstance(a, SingleAttr), self._attr_list)
        return map(lambda f: f.name, fields)

    def types(self):
        types = filter(lambda a: isinstance(a, Collection), self._attr_list)
        return map(lambda t: t.name, types)

    def has_type(self, type_name):
        if self._attrs.has_key(type_name):
            if isinstance(self._attrs[type_name], Collection):
                return True
        return False

    def has_field(self, type_name):
        if self._attrs.has_key(type_name):
            if isinstance(self._attrs[type_name], SingleAttr):
                return True
        return False

    def fetch_one_for_type(self, object_type, id_):
        if not is_valid_uuid(id_):
            return None

        if not self.has_type(object_type):
            raise Exception("%s: no such member %s" % (object_type, id_))

        attr = self.attrs()[object_type]
        if not attr.getter:
            return None

        func = app.reflect(attr.getter)
        try:
            obj = func(id_)
        except:
            return None
        return attr.element_type(obj) if obj else None

    def fetch_all_for_type(self, object_type):
        if not self.has_type(object_type):
            raise Exception("%s: no such member" % object_type)

        attr = self.attrs()[object_type]
        if not attr.list_method:
            return []
        func = self.reflect(attr.list_method)
        if attr.list_with_tenant:
            objects = func({'tenant_id':session.tenant_id})
        else:
            objects = func()
        return map(lambda elem: attr.element_type(elem), objects)

    def reflect(self, member_name):
        try:
            memb = getattr(self._object, member_name)
            if memb is None:
                raise Exception
            return memb
        except:
            raise Exception("bug in type definition: %s::%s" % (
                self.__class__.__name__, member_name))

    def fetch_field(self, field_name):
        if not self.has_field(field_name):
            raise Exception("%s: no such member" % field_name)

        return self.attrs()[field_name].fetch(self)

    def set_field(self, field_name, value):
        if not self.has_field(field_name):
            raise Exception("%s: no such member" % field_name)

        return self.attrs()[field_name].set(self, value)

    def fetch_and_wrap_field(self, field_name):
        val = self.fetch_field(field_name)
        if not val:
            return None

        spec = self.attrs()[field_name]
        return FieldType(field_name, spec, val).dereference()

    def _value_to_str(self, value):
        if isinstance(value, ObjectType):
            return aliases.add(value).pop()
        else:
            return value.value

    def describe(self):
        # TODO - create aliases for object refs
        flist = filter(lambda f: self.attrs()[f].show, self.fields())
        flist = filter(lambda f: self.fetch_field(f), flist)
        values = map(lambda f: self.fetch_and_wrap_field(f), flist)
        values = map(lambda v: self._value_to_str(v), values)
        return " ".join(map(lambda (f, v): "%s %s" % (f, v), zip(flist, values)))

class Route(ObjectType):
    def __init__(self, obj):
        ObjectType.__init__(self, obj)
        self.put_attr(SingleAttr(name = 'type',
                                 value_type = StringType(),
                                 getter = 'get_type',
                                 setter = 'type'))
        self.put_attr(CidrPair(name = 'src',
                               value_type = StringType(),
                               addr_getter = 'get_src_network_addr',
                               mask_getter = 'get_src_network_length',
                               addr_setter = 'src_network_addr',
                               mask_setter = 'src_network_length',
                               optional = True))
        self.put_attr(CidrPair(name = 'dst',
                               value_type = StringType(),
                               addr_getter = 'get_dst_network_addr',
                               mask_getter = 'get_dst_network_length',
                               addr_setter = 'dst_network_addr',
                               mask_setter = 'dst_network_length'))
        self.put_attr(SingleAttr(name = 'gw',
                                 value_type = StringType(),
                                 getter = 'get_next_hop_gateway',
                                 setter = 'next_hop_gateway',
                                 optional = True))
        self.put_attr(SingleAttr(name = 'port',
                                 value_type = ObjectRef('port'),
                                 getter = 'get_next_hop_port',
                                 setter = 'next_hop_port',
                                 optional = True))
        self.put_attr(SingleAttr(name = 'weight',
                                 value_type = StringType(),
                                 getter = 'get_weight',
                                 setter = 'weight',
                                 optional = True))

    def type_name(self):
        return "router"

class Router(ObjectType):
    def __init__(self, obj):
        ObjectType.__init__(self, obj)
        # NOTE: factory method is a hack, the type attribute may later change
        # the port type to exterior.
        self.put_attr(TenantAttr())
        self.put_attr(Collection(name = 'port',
                                 element_type = RouterPort,
                                 list_method = 'get_ports',
                                 getter = 'get_port',
                                 factory_method = 'add_interior_port'))
        self.put_attr(Collection(name = 'route',
                                 element_type = Route,
                                 list_method = 'get_routes',
                                 getter = 'get_route',
                                 factory_method = 'add_route'))
        # TODO - add peer ports. - they need aliases in the root namespace
        # or with a different prefix. Right now there's no support for either.
        self.put_attr(SingleAttr(name = 'name',
                                 value_type = StringType(),
                                 getter = 'get_name',
                                 setter = 'name',
                                 writeable = False,
                                 optional = True))
        self.put_attr(SingleAttr(name = 'infilter',
                                 value_type = ObjectRef('chain'),
                                 getter = 'get_inbound_filter_id'))
        self.put_attr(SingleAttr(name = 'outfilter',
                                 value_type = ObjectRef('chain'),
                                 getter = 'get_outbound_filter_id'))

    def type_name(self):
        return "router"

class Bridge(ObjectType):
    def __init__(self, obj):
        ObjectType.__init__(self, obj)
        self.put_attr(TenantAttr())
        self.put_attr(Collection(name = 'port',
                                 element_type = BridgePort,
                                 list_method = 'get_ports',
                                 getter = 'get_port',
                                 factory_method = 'add_interior_port'))
        self.put_attr(SingleAttr(name = 'name',
                                 value_type = StringType(),
                                 setter = 'name',
                                 getter = 'get_name'))
        self.put_attr(SingleAttr(name = 'infilter',
                                 value_type = ObjectRef('chain'),
                                 getter = 'get_inbound_filter_id'))
        self.put_attr(SingleAttr(name = 'outfilter',
                                 value_type = ObjectRef('chain'),
                                 getter = 'get_outbound_filter_id'))

    def type_name(self):
        return "bridge"

class Chain(ObjectType):
    def __init__(self, obj):
        ObjectType.__init__(self, obj)
        self.put_attr(TenantAttr())
        self.put_attr(Collection(name = 'rule',
                                 element_type = Rule,
                                 list_method = 'get_rules',
                                 getter = 'get_port',
                                 factory_method = 'add_rule'))
    def type_name(self):
        return "chain"

class Rule(ObjectType):
    def __init__(self, obj):
        ObjectType.__init__(self, obj)
        self.put_attr(SingleAttr(name = 'type',
                                 value_type = StringType(),
                                 getter = 'get_type'))
        self.put_attr(SingleAttr(name = 'action',
                                 value_type = StringType(),
                                 getter = 'get_flow_action'))
        # TODO -- complete

    def type_name(self):
        return "rule"

class BridgePort(ObjectType):
    def type_name(self):
        return "port"

    def __init__(self, obj):
        ObjectType.__init__(self, obj)
        self.put_attr(SingleAttr(name = 'type',
                                 value_type = StringType(),
                                 getter = 'get_type',
                                 setter = 'type',
                                 optional = False))
        self.put_attr(SingleAttr(name = 'device',
                                 value_type = ObjectRef('bridge'),
                                 getter = 'get_device_id'))
        self.put_attr(SingleAttr(name = 'infilter',
                                 value_type = ObjectRef('chain'),
                                 getter = 'get_inbound_filter_id'))
        self.put_attr(SingleAttr(name = 'outfilter',
                                 value_type = ObjectRef('chain'),
                                 getter = 'get_outbound_filter_id'))

class PortBinding(ObjectType):
    def type_name(self):
        return "port_binding"

    def __init__(self, obj):
        ObjectType.__init__(self, obj)
        self.clear_attrs()
        self.put_attr(SingleAttr(name = 'host',
                                 value_type = ObjectRef('host'),
                                 getter = 'get_host_id',
                                 optional = False))
        self.put_attr(SingleAttr(name = 'interface',
                                 value_type = StringType(),
                                 getter = 'get_interface_name',
                                 setter = 'interface_name',
                                 optional = False))
        # TODO - need support for mapping the result to the correct
        # port subclass
        self.put_attr(SingleAttr(name = 'port',
                                 value_type = ObjectRef('port'),
                                 getter = 'get_port_id',
                                 setter = 'port_id',
                                 optional = False))

class Host(ObjectType):
    def type_name(self):
        return "host"

    def __init__(self, obj):
        ObjectType.__init__(self, obj)
        self.put_attr(SingleAttr(name = 'name', value_type = StringType(),
                                 getter = 'get_name', writeable = False))
        self.put_attr(SingleAttr(name = 'alive', value_type = StringType(),
                                 getter = 'is_alive', writeable = False))
        self.put_attr(SingleAttr(name = 'addresses', value_type = StringType(),
                                 getter = 'get_addresses', writeable = False))
        self.put_attr(Collection(name = 'interface',
                                 element_type = Interface,
                                 list_method = 'get_interfaces'))
        self.put_attr(Collection(name = 'binding',
                                 element_type = PortBinding,
                                 list_method = 'get_ports',
                                 factory_method = 'add_host_interface_port'))

class Interface(ObjectType):
    def type_name(self):
        return "interface"

    def __init__(self, obj):
        ObjectType.__init__(self, obj)
        self.clear_attrs()
        self.put_attr(SingleAttr(name = 'iface', value_type = StringType(),
                                 getter = 'get_name', writeable = False))
        self.put_attr(SingleAttr(name = 'host_id', value_type = ObjectRef('host'),
                                 getter = 'get_host_id', writeable = False))
        self.put_attr(SingleAttr(name = 'status', value_type = StringType(),
                                 getter = 'get_status', writeable = False))
        self.put_attr(SingleAttr(name = 'addresses', value_type = StringType(),
                                 getter = 'get_addresses', writeable = False))
        self.put_attr(SingleAttr(name = 'mac', value_type = StringType(),
                                 getter = 'get_mac', writeable = False))
        self.put_attr(SingleAttr(name = 'mtu', value_type = StringType(),
                                 getter = 'get_mtu', writeable = False))
        self.put_attr(SingleAttr(name = 'type', value_type = StringType(),
                                 getter = 'get_type', writeable = False))
        self.put_attr(SingleAttr(name = 'endpoint', value_type = StringType(),
                                 getter = 'get_endpoint', writeable = False))

class RouterPort(ObjectType):
    def type_name(self):
        return "port"

    def __init__(self, obj):
        ObjectType.__init__(self, obj)
        self.put_attr(SingleAttr(name = 'type',
                                 value_type = StringType(),
                                 getter = 'get_type',
                                 setter = 'type',
                                 optional = False))
        self.put_attr(SingleAttr(name = 'device',
                                 value_type = ObjectRef('router'),
                                 getter = 'get_device_id'))
        self.put_attr(SingleAttr(name = 'infilter',
                                 value_type = ObjectRef('chain'),
                                 getter = 'get_inbound_filter_id',
                                 setter = 'inbound_filter_id'))
        self.put_attr(SingleAttr(name = 'outfilter',
                                 value_type = ObjectRef('chain'),
                                 getter = 'get_outbound_filter_id',
                                 setter = 'outbound_filter_id'))
        self.put_attr(SingleAttr(name = 'mac',
                                 value_type = StringType(),
                                 getter = 'get_port_mac',
                                 setter = 'port_mac',
                                 optional = False))
        self.put_attr(SingleAttr(name = 'address',
                                 value_type = StringType(),
                                 getter = 'get_port_address',
                                 setter = 'port_address'))
        self.put_attr(CidrPair(name = 'net',
                               value_type = StringType(),
                               addr_getter = 'get_network_address',
                               mask_getter = 'get_network_length',
                               addr_setter = 'network_address',
                               mask_setter = 'network_length'))

class Midonet(ObjectType):
    """ This is the root context for the CLI. At the beggining of matchin on a
        command pattern the `MatchingContext` is initialized with an instance of
        this object. Thus, its mission is to give access to top-level objects in
        the REST API"""

    def __init__(self, app):
        ObjectType.__init__(self, app)
        self.clear_attrs()
        ObjectType.put_attr(self, Collection(name = 'router',
                                             element_type = Router,
                                             list_method = 'get_routers',
                                             getter = 'get_router',
                                             list_with_tenant = True,
                                             factory_method = 'add_router'))
        ObjectType.put_attr(self, Collection(name = 'bridge',
                                             element_type = Bridge,
                                             list_method = 'get_bridges',
                                             getter = 'get_bridge',
                                             list_with_tenant = True,
                                             factory_method = 'add_bridge'))
        ObjectType.put_attr(self, Collection(name = 'chain',
                                             element_type = Chain,
                                             list_method = 'get_chains',
                                             getter = 'get_chain',
                                             list_with_tenant = True,
                                             factory_method = 'add_chain'))
        ObjectType.put_attr(self, Collection(name = 'host',
                                             element_type = Host,
                                             list_method = 'get_hosts',
                                             getter = 'get_host'))

################################################################################
# Grammar tokens
################################################################################

class ParsingSubmatch():
    def __init__(self, context):
        self._context = context

    def unparsed_args(self):
        return len(self._context.args())

    def best_match(self, that):
        if self.unparsed_args() < that.unparsed_args():
            return self
        else:
            return that

    def describe(self):
        if len(self._context.args()) > 0:
            return "Syntax error at: ...%s" % " ".join(self._context.args())
        else:
            return "Missing arguments, incomplete command"

class MatchingContext():
    """ The MatchingContext accumulates results as tokens in a command pattern
        are matched. It is immutable so partial matches can be undone by the
        engine to move on to the next candidate pattern.

        Matching CommandTokens return a newly modified context (using the `copy`
        method), they may choose to modify zero (the token has no effect) or
        more of the following pieces of data:

            obj:    Modifies the current context object in which subsequent
                    tokens may do lookups (for fields or members for example)

            args:   Modifies the list of words that remain to be parsed in the
                    current command. Most of the time CommandTokens will remove
                    items from the beginning of this sequence to consume input.

            parsed: Contains the tokens/items that will be passed to the Command
                    object if this chain of tokens results in a successful,
                    complete match. Most of the time, tokens will either add
                    themselves here or objects that they resolved.
    """

    def __init__(self, obj, args, parsed = []):
        self._object = obj
        self._args = args
        self._parsed = list(parsed)

    def object(self):
        return self._object

    def args(self):
        return list(self._args)

    def parsed_tokens(self):
        return list(self._parsed)

    def copy(self, obj = None, args = None, new_tokens = []):
        o = obj if obj is not None else self._object
        a = args if args is not None else self._args
        p = list(self._parsed)
        p.extend(new_tokens)
        return MatchingContext(o, tuple(a), p)

class CommandToken():
    def __init__(self):
        pass

    def matches(self, context):
        return ParsingSubmatch(context)

    def complete(self, context):
        return []

class Verb(CommandToken):
    """Matches a literal word, usually representing a verb or command"""

    def __init__(self, name, partial_match = True, min_match = None):
        self._name = name
        self._partial = partial_match
        self._min = min_match

    def matches(self, context):
        args = context.args()
        if len(args) == 0:
            return ParsingSubmatch(context)
        v = args[0]
        if (v == self._name) or (self._partial and self._name.startswith(v)):
            if self._min is None or v.startswith(self._min):
                args.pop(0)
                return context.copy(args = args, new_tokens = [self])
        return ParsingSubmatch(context)

    def complete(self, context):
        args = context.args()
        if len(args) == 1 and self._name.startswith(args[0]):
            return [self._name]
        else:
            return []

class OnceOrMore(CommandToken):
    def __init__(self, token):
        self._token = token

    def matches(self, context):
        res = self._token.matches(context)
        while isinstance(res, MatchingContext):
            submatch = self._token.matches(res)
            if isinstance(submatch, MatchingContext):
                res = submatch
            else:
                break
        if res is None:
            return ParsingSubmatch(context)
        else:
            return res

    def complete(self, context):
        lastMatch = context
        while True:
            res = self._token.matches(lastMatch)
            if isinstance(res, MatchingContext):
                if len(res.args()) == 0:
                    return self._token.complete(lastMatch)
                lastMatch = res
            else:
                return self._token.complete(lastMatch)

class ZeroOrMore(CommandToken):
    def __init__(self, token):
        self._token = token

    def matches(self, context):
        while True:
            submatch = self._token.matches(context)
            if isinstance(submatch, MatchingContext):
                context = submatch
            else:
                return context

    def complete(self, context):
        while True:
            submatch = self._token.matches(context)
            if isinstance(submatch, MatchingContext):
                if len(submatch.args()) == 0:
                    return self._token.complete(context)
                context = submatch
            else:
                return self._token.complete(context)
        return []

class ZeroOrOne(CommandToken):
    def __init__(self, token):
        self._token = token

    def matches(self, context):
        res = self._token.matches(context)
        return res if isinstance(res, MatchingContext) else context

    def complete(self, context):
        return self._token.complete(context)

class Or(CommandToken):
    def __init__(self, *tokens):
        self._tokens = list(tokens)

    def matches(self, context):
        submatch = ParsingSubmatch(context)
        for token in self._tokens:
            res = token.matches(context)
            if res is None:
                continue
            elif isinstance(res, MatchingContext):
                return res
            elif isinstance(res, ParsingSubmatch):
                submatch = submatch.best_match(res)
            else:
                raise Exception("parser bug")
        return submatch

    def complete(self, context):
        completions = []
        for token in self._tokens:
            completions += token.complete(context)
        return completions

class CollectionByType(CommandToken):
    """Matches an collection of objects contained in another object.
       Matches on one word: the collection name (e.g. 'router')"""

    def matches(self, context):
        args = context.args()
        if (len(args) < 1):
            return None

        object_type = args.pop(0)
        if context.object().has_type(object_type):
            collection = context.object().attrs()[object_type]
            return context.copy(None, args, [collection])
        else:
            return ParsingSubmatch(context)

    def complete(self, context):
        args = context.args()
        if (len(args) != 1):
            return []

        completions = []
        object_type = args.pop(0)
        for t in context.object().types():
            if t.startswith(object_type):
                completions.append(t)
        return completions

class RootCtxToken(CommandToken):
    """ Always matches, consuming zero input arguments and inserting the current
        context into the parsed args set. Meant to be used to allow commands to
        operate directly on the root context."""

    def matches(self, context):
        return context.copy(None, None, [context.object()])

class NewObjectFieldAssignment(CommandToken):
    def matches(self, context):
        args = context.args()
        if (len(args) < 2):
            return ParsingSubmatch(context)

        col = None
        for tok in context.parsed_tokens():
            if isinstance(tok, Collection):
                col = tok
        if not col:
            return ParsingSubmatch(context)

        stub = col.element_type(None)
        obj = context.object()
        fname = args.pop(0)
        if stub.has_field(fname):
            fspec = stub.attrs()[fname]
            if isinstance(fspec.value_type, ObjectRef):
                refmatch = OnceOrMore(ObjectById()).matches(context.copy(app, args))
                if isinstance(refmatch, MatchingContext):
                    fval = refmatch.object()
                    field = FieldType(fname, fspec, fval.fetch_field('id'))
                    return context.copy(obj, refmatch.args(), [field])
                else:
                    fval = args.pop(0)
                    fromalias = aliases.lookup(fval)
                    if fromalias:
                        field = FieldType(fname, fspec, fromalias)
                        return context.copy(obj, args, [field])
                    else:
                        return ParsingSubmatch(context)
            else:
                fval = args.pop(0)
                field = FieldType(fname, fspec, fval)
                return context.copy(obj, args, [field])
        return ParsingSubmatch(context)

    def complete(self, context):
        args = context.args()
        if len(args) < 1 or len(args) > 2:
            return []

        col = None
        for tok in context.parsed_tokens():
            if isinstance(tok, Collection):
                col = tok
        if not col:
            return []
        stub = col.element_type(None)

        if len(args) == 1:
            return FieldByName().complete(context.copy(obj = stub))

        fname = args.pop(0)
        fval = args.pop(0)
        if not stub.has_field(fname):
            return []

        fspec = stub.attrs()[fname]
        if isinstance(fspec, ObjectRef):
            return aliases.complete(fval)
        else:
            return []

class FieldAssignment(CommandToken):
    def matches(self, context):
        args = context.args()
        if (len(args) < 2):
            return ParsingSubmatch(context)

        obj = context.object()
        if not obj:
            return ParsingSubmatch(context)

        fname = args.pop(0)
        fval = args.pop(0)
        if obj.has_field(fname):
            # TODO - object refs, reuse code from NewObjectFieldAssignment
            fspec = obj.attrs()[fname]
            field = FieldType(fname, fspec, fval)
            return context.copy(obj, args, [field])
        return ParsingSubmatch(context)

    def complete(self, context):
        args = context.args()
        if len(args) < 1 or len(args) > 2:
            return []

        obj = context.object()
        if not obj:
            return []

        if len(args) == 1:
            return FieldByName().complete(context)

        fname = args.pop(0)
        fval = args.pop(0)
        if not obj.has_field(fname):
            return []

        fspec = obj.attrs()[fname]
        if isinstance(fspec, ObjectRef):
            return aliases.complete(fval)
        else:
            return []

class ObjectById(CommandToken):
    """Matches an object within a collection identified by its UUID or CLI
       alias. Matches on two words: collection name (e.g. 'router') plus the
       id/alias itself. The lookup is done in the current matching context."""

    def matches(self, context):
        args = context.args()
        if (len(args) < 1):
            return ParsingSubmatch(context)

        object_type = args.pop(0)
        if not context.object().has_type(object_type):
            return ParsingSubmatch(context)

        if (len(args) < 1):
            return ParsingSubmatch(context.copy(args = args))
        object_id = args.pop(0)

        aliased_id = aliases.lookup(object_id, context.object())
        if aliased_id is not None:
            object_id = aliased_id

        subobject = context.object().fetch_one_for_type(object_type, object_id)
        if subobject:
            return context.copy(subobject, args, [subobject])

        non_parsed = context.args()
        non_parsed.pop(0)
        return ParsingSubmatch(context.copy(args = non_parsed))

    def complete(self, context):
        args = context.args()
        if len(args) < 1 or len(args) > 2:
            return []

        if (len(args) == 1):
            return CollectionByType().complete(context)

        object_type = args.pop(0)
        if not context.object().has_type(object_type):
            return []

        object_id = args.pop(0)
        return aliases.complete(object_id, context.object())

class FieldByName(CommandToken):
    """Matches a field in the object found in the current matching context"""

    def matches(self, context):
        args = context.args()
        if (len(args) == 0):
            return ParsingSubmatch(context)
        fname = args.pop(0)
        if context.object().has_field(fname):
            fspec = context.object().attrs()[fname]
            value = context.object().fetch_field(fname)
            if value is None:
                return context.copy(context.object(), args, [""])
            parsed = FieldType(fname, fspec, value).dereference()
            if parsed is None:
                raise Exception("reference to a dead object: %s" % value)
            obj = parsed if isinstance(parsed, ObjectType) else context.object()
            return context.copy(obj, args, [parsed])
        return ParsingSubmatch(context)

    def complete(self, context):
        args = context.args()
        if (len(args) == 0):
            return []

        completions = []
        arg = args.pop(0)
        for f in context.object().fields():
            if f.startswith(arg):
                completions.append(f)
        return completions

class ObjectRefField(CommandToken):
    """Matches a field of type ObjectRef"""

    def matches(self, context):
        args = context.args()
        if (len(args) == 0):
            return ParsingSubmatch(context)

        fname = args.pop(0)
        if not context.object().has_field(fname):
            return ParsingSubmatch(context)

        fspec = context.object().attrs()[fname]
        if not isinstance(fspec.value_type, ObjectRef):
            return ParsingSubmatch(context)

        value = context.object().fetch_field(fname)
        if value is None or value == "":
            return ParsingSubmatch(context)

        parsed = FieldType(fname, fspec, value).dereference()
        if parsed is None or not isinstance(parsed, ObjectType):
            return ParsingSubmatch(context)

        return context.copy(parsed, args, [parsed])

class ObjectSelector(Or):
    def __init__(self):
        Or.__init__(self, ObjectRefField(), ObjectById())

################################################################################
# Commands
################################################################################

class Command():
    """ Base abstract class for CLI Commands """
    def __init__(self):
        pass

    def name(self):
        pass

    def help(self):
        pass

    def patterns(self):
        """Returns a list of CommandToken objects representing acceptable
           syntaxes for this command. The engine will select this command when
           the returned token list is an exact match for the command being
           parsed"""
        raise Exception("Unimplemented command")

    def do(self, tokens):
        """Executes this command. The engine will call this method after a
           successful match. `tokens` is the sequence of matched tokens. Note,
           however, that these will be a mix of CommandToken instances and API
           wrapper objects (see ObjectType) matched by a token.

           Usually Verb tokens are passed as is while other tokens produce API
           objects that the Verb should act on.

           For example, given the pattern:

               [ObjectById(), Verb('show'), ZeroOrMore(ObjectById())]

           The following command would be a match:

               midonet> router foo show port bar

           ...and produce these tokens: Router, Verb, Port. Where Router would
           be an ObjectType subclass wrapping a router API object, Verb should
           be Verb('show') (a CommandToken) and Port would be an ObjectType
           subclass wrapping the API object that represents port 'bar' in router
           'foo'.
           """
        raise Exception("Unimplemented command")

class Describe(Command):
    def patterns(self):
        describe = Verb('describe', min_match = 'desc')
        obj_selector = Or(OnceOrMore(ObjectById()), RootCtxToken())

        return [ [obj_selector, describe ],
                 [describe, obj_selector ]]

    def name(self):
        return 'describe'

    def help(self):
        print """describe - Show the names of members of an object

    Usage: desc[ribe] [<OBJECT> {<CHILD>}]
           <OBJECT> {<CHILD>} desc[ribe]
    Examples:
           describe
           describe router router0
           router router0 port port2 describe"""

    def do(self, tokens):
        assert(len(tokens) >= 1)
        object_chain = []
        for o in tokens:
            if (isinstance(o, ObjectType)):
                object_chain.append(o)
            elif isinstance(o, FieldType):
                print "%s" % o.describe()
                return

        ref = object_chain.pop()
        collections = list(ref.types())
        fields = list(ref.fields())
        print "Object collections:"
        cli.stdout.write("    ")
        if len(collections) > 0:
            cli.columnize(collections, 76)
        else:
            print "<NONE>"
        print "Fields:"
        cli.stdout.write("    ")
        if len(fields) > 0:
            cli.columnize(fields, 76)
        else:
            print "<NONE>"

class Create(Command):
    def patterns(self):
        create = Or(Verb('create', partial_match = False),
                    Verb('add', partial_match = False))
        return [ [ create,
                   ZeroOrMore(ObjectById()),
                   CollectionByType(),
                   ZeroOrMore(NewObjectFieldAssignment()) ],
                 [ ZeroOrMore(ObjectById()),
                   create,
                   CollectionByType(),
                   ZeroOrMore(NewObjectFieldAssignment()) ],
                 [ ZeroOrMore(ObjectById()),
                   CollectionByType(),
                   create,
                   ZeroOrMore(NewObjectFieldAssignment()) ] ]

    def help(self):
        print """create - Create a new object

    Usage: create|add [<OBJECT> {<CHILD>}] <TYPE> {<FIELD> <VALUE>}
           [<OBJECT> {<CHILD>}] create|add <TYPE> {<FIELD> <VALUE>}
           [<OBJECT> {<CHILD>}] <TYPE> create|add {<FIELD> <VALUE>}

    Examples:
           create router name 'new router'
           router router0 add port type interior address 1.1.1.1 net 1.1.1.0/24
           """

    def name(self):
        return 'create'

    def do(self, tokens):
        assert(len(tokens) >= 2)
        obj = app
        fields = []
        collection = None
        for tok in tokens:
            if isinstance(tok, ObjectType):
                obj = tok
            elif isinstance(tok, FieldType):
                fields.append(tok)
            elif isinstance(tok, Collection):
                collection = tok

        if not collection.factory_method:
            raise Exception("Creating elements of this type is not possible")
        factory = obj.reflect(collection.factory_method)
        new_object = factory()
        wrapper = collection.element_type(new_object)
        for f in fields:
            wrapper.set_field(f.name, f.value)
        if wrapper.has_field('tenant_id'):
            wrapper.set_field('tenant_id', session.tenant_id)
        new_object.create()

class Set(Command):
    def patterns(self):
        return [ [ Verb('set', partial_match = False),
                   OnceOrMore(ObjectById()),
                   OnceOrMore(FieldAssignment()) ],
                 [ OnceOrMore(ObjectById()),
                   Verb('set', partial_match = False),
                   OnceOrMore(FieldAssignment()) ] ]

    def help(self):
        print """set - Update values in an existing object

    Usage: set <OBJECT> {<CHILD>} <FIELD> <VALUE> {<FIELD> <VALUE>}
           <OBJECT> {<CHILD>} set <FIELD> <VALUE> {<FIELD> <VALUE>}

    Examples:
           set router router name 'new name for router'
           router router0 port port0 set address 1.1.1.1 net 1.1.1.0/24
           """

    def name(self):
        return 'set'

    def do(self, tokens):
        assert(len(tokens) >= 3)
        obj = None
        fields = []
        for tok in tokens:
            if isinstance(tok, ObjectType):
                obj = tok
            elif isinstance(tok, FieldType):
                fields.append(tok)
        assert(obj is not None)

        for f in fields:
            obj.set_field(f.name, f.value)
        obj.object().update()

class Delete(Command):
    def patterns(self):
        return [ [ Verb('delete', partial_match = False),
                   OnceOrMore(ObjectById()) ],
                 [ OnceOrMore(ObjectById()),
                   Verb('delete', partial_match = False),
                   ZeroOrMore(ObjectById()) ] ]

    def help(self):
        print """delete - Delete an object

    Usage: delete <OBJECT> {<CHILD>}
           <OBJECT> {<CHILD>} delete {<CHILD>}

    Examples:
           delete router router0 name 'new name for router'
           router router0 port port0 delete
           router router0 delete port port0
           """

    def name(self):
        return 'set'

    def do(self, tokens):
        assert(len(tokens) >= 2)
        obj = None
        for tok in tokens:
            if isinstance(tok, ObjectType):
                obj = tok
        assert(obj is not None)
        obj.object().delete()

class Show(Command):
    def patterns(self):
        return [ [ ObjectById(),
                   Verb('show'),
                   ZeroOrMore(ObjectById()),
                   ZeroOrOne(FieldByName()) ],
                 [ ZeroOrOne(Verb('show')),
                   OnceOrMore(ObjectById()),
                   ZeroOrOne(FieldByName()) ],
                 [ OnceOrMore(ObjectById()),
                   ZeroOrOne(FieldByName()),
                   Verb('show') ],
                 [ OnceOrMore(ObjectById()),
                   Verb('show'),
                   ZeroOrOne(FieldByName()) ]]

    def name(self):
        return 'show'

    def help(self):
        print """show - Show an object or field

    Usage: s[how] <OBJECT> {<CHILD>} [<FIELD>]
           <OBJECT> s[how] {<CHILD>} [<FIELD>]
           <OBJECT> {<CHILD>} s[how] [<FIELD>]
           <OBJECT> {<CHILD>} [<FIELD>] s[how]
           <OBJECT> {<CHILD>} [<FIELD>]

    Examples:
           show router router0
           sh router router0 port port2
           router router0 port port2 show infilter"""

    def do(self, tokens):
        assert(len(tokens) >= 1)
        object_chain = []
        for o in tokens:
            if (isinstance(o, ObjectType)):
                object_chain.append(o)
            elif isinstance(o, FieldType):
                print "%s" % o.describe()
                return

        alias_chain = aliases.add(*object_chain)
        ref = object_chain.pop()
        alias = alias_chain.pop()
        print "%s %s %s" % (ref.type_name(), alias, ref.describe())

class List(Command):
    def patterns(self):
        obj_selector = Or(OnceOrMore(ObjectById()), RootCtxToken())

        return [ [obj_selector, Verb('list'), CollectionByType()],
                 [Verb('list'), obj_selector, CollectionByType()],
                 [obj_selector, CollectionByType(), Verb('list')] ]

    def name(self):
        return 'list'

    def help(self):
        print """list - List the children of an object of a given type

    Usage: l[ist] [<OBJECT> {<CHILD>}] <COLlECTION_NAME>
           <OBJECT> l[ist] {<CHILD>} <COLlECTION_NAME>
           [<OBJECT> {<CHILD>}] <COLlECTION_NAME> l[ist]
    Examples:
           list router
           router router0 list port
           router router0 route list"""

    def do(self, tokens):
        ref = None
        collection = None
        chain = []
        for tok in tokens:
            if isinstance(tok, Verb):
                continue
            elif isinstance(tok, Collection):
                collection = tok
            elif isinstance(tok, ObjectType):
                ref = tok
                if not isinstance(tok, Midonet):
                    chain.append(tok)
        assert(ref is not None and collection is not None)

        for o in ref.fetch_all_for_type(collection.name):
            if o.has_field('id'):
                ch = list(chain) + [o]
                alias = aliases.add(*ch).pop()
                print "%s %s %s" % (o.type_name(), alias, o.describe())
            else:
                print o.describe()

################################################################################
# Upstream API object mocks
################################################################################

class MockObject():
    def __init__(self, ident):
        self._id = ident
        self._ports = {}
        self._in_filter = None

    def get_id(self):
        return self._id

    def get_device_id(self):
        return 'foo'

    def get_type(self):
        return 'InteriorRouter'

    def get_port_mac(self):
        return '00:00:11:11:22:22'

    def get_port_address(self):
        return '192.168.100.1'

    def get_network_address(self):
        return '192.168.100.0'

    def get_network_length(self):
        return '25'

    def get_name(self):
        return "mock-object-name-%s" % self._id

    def name(self, value):
        pass

    def get_ports(self):
        return list(self._ports.itervalues())

    def get_rules(self):
        return []

    def get_inbound_filter_id(self):
        return self._in_filter

    def get_outbound_filter_id(self):
        return None

    def add_port(self):
        new_p = MockObject("new_port_%d" % len(self.get_ports()))
        self._ports[new_p.get_id()] = new_p
        return new_p

    def create(self):
        print "created object: %s" % self._id

    def update(self):
        print "updated object: %s" % self._id

    def delete(self):
        print "deleted object: %s" % self._id

class MockApp():
    def __init__(self):
        f = MockObject('chain-XYZ')
        self._chains = {f.get_id():f}
        r = MockObject('foo')
        r.add_port()
        r._in_filter = f.get_id()
        self._routers = {r.get_id() : r}
        self.add_router()

    def get_router(self, id_):
        if self._routers.has_key(id_):
            return self._routers[id_]
        else:
            return None

    def get_chain(self, id_):
        if self._chains.has_key(id_):
            return self._chains[id_]
        else:
            return None

    def get_routers(self, query):
        return list(self._routers.itervalues())

    def get_chains(self, query):
        return list(self._chains.itervalues())

    def add_router(self):
        new_r = MockObject("new_router_%d" % len(self.get_routers(None)))
        self._routers[new_r.get_id()] = new_r
        return new_r

class MockSession():
    def __init__(self):
        self.tenant_id = 'unused'
        self.enable_alias_manager = True
        self.do_eval = False

    def load(self):
        pass

    def connect(self):
        return MockApp()

################################################################################
# Command loop
################################################################################

class MidonetCLI(cmd.Cmd):
    prompt = 'midonet> '

    def __init__(self, root):
        readline.set_completer_delims("")
        readline.set_completion_display_matches_hook(self.display_completions)
        cmd.Cmd.__init__(self)
        self._root = root
        self._ops = [Show(), List(), Describe(), Create(), Delete(), Set()]
        for op in self._ops:
            if op.name() is not None:
                setattr(self, "help_%s" % op.name(), op.help)

    def do_help(self, arg):
        if arg:
            cmd.Cmd.do_help(self, arg)
        else:
            commands = map(lambda c: c.name(), self._ops)
            commands.append('exit')
            commands.append('quit')
            print "Type 'help COMMAND' for detailed help."
            print ""
            print "Available commands:"
            self.stdout.write("\n    ")
            self.columnize(commands, 76)

    def help_exit(self):
        print "quit - end the current session and exit"

    def help_quit(self):
        print "exit - end the current session and exit"

    def emptyline(self):
        pass

    def do_EOF(self, line):
        print ""
        return True

    def do_exit(self, line):
        return True

    def do_quit(self, line):
        return True

    def match_command(self, context, pattern):
        last_submatch = ParsingSubmatch(context)
        for token in pattern:
            context = token.matches(context)
            if context is None:
                return last_submatch
            elif isinstance(context, ParsingSubmatch):
                return context
            elif isinstance(context, MatchingContext):
                last_submatch = ParsingSubmatch(context)
            else:
                raise Exception("parser bug")

        if len(context.args()) == 0:
            return context
        else:
            return last_submatch

    def default(self, line):
        try:
            args = shsplit(line)
        except:
            print "Syntax error: unmatched quote"
            return False
        context = MatchingContext(self._root, args)

        try:
            error = ParsingSubmatch(context)
            for op in self._ops:
                for pattern in op.patterns():
                    result = self.match_command(context, pattern)
                    if isinstance(result, MatchingContext):
                        op.do(result.parsed_tokens())
                        return False
                    elif isinstance(result, ParsingSubmatch):
                        error = error.best_match(result)
            print error.describe()
        except Exception as e:
            print "Internal error: %s" % e

        return False

    def complete_command(self, context, pattern):
        previous = None
        for token in pattern:
            if len(context.args()) == 1:
                return token.complete(context)

            res = token.matches(context)
            if isinstance(res, MatchingContext):
                if len(res.args()) == 0:
                    return token.complete(context)
                previous = context
                context = res
            else:
                return token.complete(context)

        if isinstance(context, MatchingContext) and previous is not None:
            if len(context.args()) == 0:
                return pattern[len(pattern)-1].complete(previous)
        else:
            return []

    def _uniq(self, seq):
        res = []
        for s in seq:
            if s not in res:
                res.append(s)
        return res

    def complete(self, line, state):
        if state == 0:
            self._cached_completions = self._complete(line, state)
        completions = self._cached_completions

        if len(completions) <= state:
            return None
        else:
            args = shsplit(line)
            if line.endswith(" ") or len(args) == 0:
                args.append("")
            args.pop()
            args.append(completions[state])
            completed = " ".join(args)
            if len(completions) == 1:
                return completed + " "
            else:
                return completed

    def _complete(self, line, state):
        completions = []
        try:
            args = shsplit(line)
        except:
            return None
        if line.endswith(" ") or len(args) == 0:
            args.append("")
        context = MatchingContext(self._root, args)
        for op in self._ops:
            for pattern in op.patterns():
                completions += self.complete_command(context, pattern)

        return self._uniq(completions)

    def display_completions(self, subst, matches, longest_len):
        words = map(lambda m: shsplit(m).pop(), matches)
        self.stdout.write("\n")
        self.columnize(words)
        self.stdout.write(self.prompt + subst)

################################################################################
# Globals
################################################################################

# Alias manager, accessible in all contexts: token matching, command execution
aliases = None

# Root context, object lookup and object tree traversal start here
app = None

cli = None

session = None

if __name__ == '__main__':
    try:
        session = Session()
        session.load()
        root = session.connect()
        aliases = AliasManager() if session.enable_alias_manager else NoOpAliasManager()
        app = Midonet(root)
        cli = MidonetCLI(app)
        if session.do_eval:
            cli.onecmd(session.command)
        else:
            cli.cmdloop()
    except Exception as e:
        sys.stderr.write(e.message + "\n")
        sys.exit(1)
